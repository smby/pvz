<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plants vs. Zombies Tower Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .ui-panel {
            height: 80px;
            background: linear-gradient(90deg, #228B22, #32CD32);
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }

        .plant-selector {
            display: flex;
            gap: 10px;
            margin-right: 20px;
            align-items: center;
        }

        .shovel-tool {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #8B4513, #A0522D);
            border: 3px solid #654321;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            margin-right: 10px;
            position: relative;
        }

        .shovel-tool:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            background: linear-gradient(135deg, #A0522D, #CD853F);
        }

        .shovel-tool.active {
            background: linear-gradient(135deg, #FF6347, #FF4500);
            border-color: #FF0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .shovel-mode {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><text y="24" font-size="24">🪓</text></svg>'), auto !important;
        }

        .cell.removable:hover {
            background: rgba(255, 0, 0, 0.3) !important;
            border-color: #FF0000 !important;
        }

        .plant-card {
            width: 60px;
            height: 60px;
            border: 3px solid #2F4F2F;
            border-radius: 8px;
            background: #90EE90;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s;
            position: relative;
        }

        .plant-card:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .plant-card.selected {
            border-color: #FFD700;
            background: #FFFF99;
        }

        .plant-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .cost {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background: #FFD700;
            border: 1px solid #B8860B;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-left: auto;
            color: white;
            font-weight: bold;
            font-size: 18px;
            align-items: center;
        }

        .encyclopedia-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #4169E1, #1E90FF);
            color: white;
            border: 2px solid #0000CD;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s;
            margin-left: 15px;
        }

        .encyclopedia-btn:hover {
            background: linear-gradient(135deg, #1E90FF, #00BFFF);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(65, 105, 225, 0.4);
        }

        .encyclopedia-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .encyclopedia-panel {
            width: 90%;
            max-width: 800px;
            height: 80%;
            background: linear-gradient(135deg, #F0F8FF, #E6F3FF);
            border: 4px solid #4169E1;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        @keyframes slideIn {
            from { transform: scale(0.8) translateY(-50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .encyclopedia-header {
            background: linear-gradient(90deg, #4169E1, #1E90FF);
            color: white;
            padding: 15px 20px;
            border-radius: 11px 11px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .encyclopedia-title {
            font-size: 24px;
            font-weight: bold;
        }

        .close-btn {
            background: #FF4500;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #FF0000;
            transform: scale(1.1);
        }

        .encyclopedia-nav {
            display: flex;
            background: #B0C4DE;
            border-bottom: 2px solid #4169E1;
        }

        .nav-tab {
            flex: 1;
            padding: 12px;
            background: #B0C4DE;
            border: none;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.2s;
            color: #2F4F4F;
        }

        .nav-tab.active {
            background: #4169E1;
            color: white;
        }

        .nav-tab:hover:not(.active) {
            background: #9FAFCF;
        }

        .encyclopedia-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #F0F8FF;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .entity-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
        }

        .entity-card {
            background: white;
            border: 2px solid #4169E1;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        .entity-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .entity-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .entity-emoji {
            font-size: 32px;
            margin-right: 12px;
        }

        .entity-name {
            font-size: 18px;
            font-weight: bold;
            color: #2F4F4F;
            margin-bottom: 4px;
        }

        .entity-cost {
            font-size: 14px;
            color: #FF8C00;
            font-weight: bold;
        }

        .entity-description {
            color: #2F4F4F;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .entity-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .stat-badge {
            background: #E6F3FF;
            border: 1px solid #4169E1;
            border-radius: 15px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: bold;
            color: #2F4F4F;
        }

        .level-progression {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #B0C4DE;
        }

        .level-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .level-emoji {
            font-size: 16px;
        }

        .game-board {
            flex: 1;
            position: relative;
            background: linear-gradient(90deg, #228B22 0%, #32CD32 50%, #228B22 100%);
            overflow: hidden;
        }

        .grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            padding: 20px;
            box-sizing: border-box;
        }

        .cell {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }

        .cell:hover {
            background: rgba(255,255,255,0.2);
        }

        .plant {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            position: relative;
            animation: plantGrow 0.3s ease-out;
        }

        .plant-level {
            position: absolute;
            top: -5px;
            left: -5px;
            background: #FFD700;
            border: 1px solid #B8860B;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #8B4513;
        }

        .upgrade-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.9);
            color: #8B4513;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            z-index: 25;
            animation: upgradeFloat 1.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes upgradeFloat {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-20px); }
        }

        @keyframes plantGrow {
            from { transform: scale(0) rotate(180deg); }
            to { transform: scale(1) rotate(0deg); }
        }

        .zombie {
            position: absolute;
            width: 50px;
            height: 60px;
            font-size: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: transform 0.1s;
        }

        .projectile {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #90EE90;
            border-radius: 50%;
            z-index: 5;
            box-shadow: 0 0 5px #32CD32;
        }

        .explosion {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #FFD700 0%, #FF6347 70%, transparent 100%);
            border-radius: 50%;
            z-index: 15;
            animation: explode 0.5s ease-out forwards;
        }

        @keyframes explode {
            from { transform: scale(0); opacity: 1; }
            to { transform: scale(2); opacity: 0; }
        }

        .damage-text {
            position: absolute;
            color: #FF4500;
            font-weight: bold;
            font-size: 16px;
            z-index: 20;
            animation: damageFloat 1s ease-out forwards;
            pointer-events: none;
        }

        @keyframes damageFloat {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-30px); opacity: 0; }
        }

        .health-bar {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #FF0000;
            border-radius: 2px;
        }

        .health-fill {
            height: 100%;
            background: #00FF00;
            border-radius: 2px;
            transition: width 0.2s;
        }

        .wave-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 1000;
            animation: waveAnnounce 2s ease-out forwards;
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 48px;
            font-weight: bold;
            z-index: 2000;
        }

        .restart-btn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 24px;
            background: #32CD32;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
        }

        .restart-btn:hover {
            background: #228B22;
        }

        .mower {
            position: absolute;
            width: 40px;
            height: 30px;
            background: #B22222;
            border: 2px solid #8B0000;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            z-index: 8;
            left: -60px;
            transition: left 2s linear;
        }

        .mower.active {
            left: 100vw;
        }

        .frozen {
            filter: hue-rotate(180deg) brightness(0.7);
            animation: freeze 0.5s ease-in-out infinite alternate;
        }

        @keyframes freeze {
            from { filter: hue-rotate(180deg) brightness(0.7); }
            to { filter: hue-rotate(180deg) brightness(1); }
        }

        .ice-trail {
            position: absolute;
            background: linear-gradient(45deg, #87CEEB, #B0E0E6);
            border: 1px solid #4682B4;
            opacity: 0.8;
            z-index: 1;
        }

        .fire-effect {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #FF4500 0%, #FF6347 50%, transparent 70%);
            border-radius: 50%;
            z-index: 12;
            animation: fireFlicker 0.3s ease-out forwards;
        }

        @keyframes fireFlicker {
            from { transform: scale(0); opacity: 1; }
            to { transform: scale(1.5); opacity: 0; }
        }

        .underground {
            opacity: 0.3;
            filter: sepia(1) hue-rotate(30deg);
        }

        .flying {
            z-index: 15;
            filter: drop-shadow(0 5px 5px rgba(0,0,0,0.3));
        }

        .pause-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #FF6B35, #F7931E);
            color: white;
            border: 2px solid #CC5500;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s;
            margin-left: 10px;
        }

        .pause-btn:hover {
            background: linear-gradient(135deg, #F7931E, #FFB84D);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        }

        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            z-index: 4000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }

        .pause-menu {
            width: 90%;
            max-width: 500px;
            background: linear-gradient(135deg, #F0F8FF, #E6F3FF);
            border: 4px solid #FF6B35;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .pause-header {
            background: linear-gradient(90deg, #FF6B35, #F7931E);
            color: white;
            padding: 20px;
            border-radius: 11px 11px 0 0;
            text-align: center;
            font-size: 28px;
            font-weight: bold;
        }

        .pause-content {
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .pause-btn-menu {
            padding: 15px 20px;
            background: linear-gradient(135deg, #4169E1, #1E90FF);
            color: white;
            border: 2px solid #0000CD;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.2s;
            text-align: center;
        }

        .pause-btn-menu:hover {
            background: linear-gradient(135deg, #1E90FF, #00BFFF);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(65, 105, 225, 0.4);
        }

        .pause-btn-menu.danger {
            background: linear-gradient(135deg, #DC143C, #B22222);
            border-color: #8B0000;
        }

        .pause-btn-menu.danger:hover {
            background: linear-gradient(135deg, #B22222, #8B0000);
            box-shadow: 0 6px 20px rgba(220, 20, 60, 0.4);
        }

        .pause-btn-menu.success {
            background: linear-gradient(135deg, #32CD32, #228B22);
            border-color: #006400;
        }

        .pause-btn-menu.success:hover {
            background: linear-gradient(135deg, #228B22, #006400);
            box-shadow: 0 6px 20px rgba(50, 205, 50, 0.4);
        }

        .wave-jump-section {
            background: rgba(255, 255, 255, 0.5);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #B0B0B0;
            margin-top: 10px;
        }

        .wave-jump-title {
            font-size: 18px;
            font-weight: bold;
            color: #2F4F4F;
            margin-bottom: 15px;
            text-align: center;
        }

        .wave-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .wave-input-label {
            font-weight: bold;
            color: #2F4F4F;
            min-width: 80px;
        }

        .wave-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #B0B0B0;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }

        .wave-input:focus {
            border-color: #4169E1;
            outline: none;
            box-shadow: 0 0 5px rgba(65, 105, 225, 0.3);
        }

        .wave-slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #B0B0B0;
            outline: none;
            margin: 10px 0;
        }

        .wave-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4169E1;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .wave-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4169E1;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .wave-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .paused-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 107, 53, 0.9);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
            z-index: 3500;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @keyframes lightning {
            0% { opacity: 1; transform: scale(1) rotate(0deg); }
            50% { opacity: 0.8; transform: scale(1.2) rotate(5deg); }
            100% { opacity: 0; transform: scale(0.8) rotate(-5deg); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="ui-panel">
            <div class="plant-selector">
                <div class="shovel-tool" id="shovel-btn" title="Remove Plants">
                    🪓
                </div>
                <div class="plant-card" data-plant="peashooter">
                    🌱
                    <div class="cost">100</div>
                </div>
                <div class="plant-card" data-plant="sunflower">
                    🌻
                    <div class="cost">50</div>
                </div>
                <div class="plant-card" data-plant="wallnut">
                    🥜
                    <div class="cost">50</div>
                </div>
                <div class="plant-card" data-plant="cherrybomb">
                    🍒
                    <div class="cost">150</div>
                </div>
                <div class="plant-card" data-plant="repeater">
                    🫛
                    <div class="cost">200</div>
                </div>
                <div class="plant-card" data-plant="iceshroom">
                    🧊
                    <div class="cost">75</div>
                </div>
                <div class="plant-card" data-plant="snapdragon">
                    🐉
                    <div class="cost">175</div>
                </div>
                <div class="plant-card" data-plant="magnetshroom">
                    🧲
                    <div class="cost">100</div>
                </div>
                <div class="plant-card" data-plant="spikeweed">
                    🌵
                    <div class="cost">100</div>
                </div>
                <div class="plant-card" data-plant="torchwood">
                    🔥
                    <div class="cost">125</div>
                </div>
                <div class="plant-card" data-plant="potatomine">
                    🥔
                    <div class="cost">25</div>
                </div>
                <div class="plant-card" data-plant="cactus">
                    🌵
                    <div class="cost">125</div>
                </div>
                <div class="plant-card" data-plant="chomper">
                    🪴
                    <div class="cost">150</div>
                </div>
                <div class="plant-card" data-plant="lightningreed">
                    ⚡
                    <div class="cost">175</div>
                </div>
                <div class="plant-card" data-plant="pumpkin">
                    🎃
                    <div class="cost">75</div>
                </div>
            </div>
            <div class="stats">
                <div>Sun: <span id="sun">150</span></div>
                <div>Wave: <span id="wave">1</span></div>
                <div>Score: <span id="score">0</span></div>
                <button class="encyclopedia-btn" id="encyclopedia-btn">📖 Guide</button>
                <button class="pause-btn" id="pause-btn">⏸️ Pause</button>
            </div>
        </div>
        <div class="game-board">
            <div class="grid" id="grid"></div>
        </div>
    </div>

    <!-- Encyclopedia Overlay -->
    <div class="encyclopedia-overlay" id="encyclopedia-overlay" style="display: none;">
        <div class="encyclopedia-panel">
            <div class="encyclopedia-header">
                <div class="encyclopedia-title">🌱 Plants vs. Zombies Guide 🧟</div>
                <button class="close-btn" id="close-encyclopedia">×</button>
            </div>
            <div class="encyclopedia-nav">
                <button class="nav-tab active" data-section="plants">🌱 Plants</button>
                <button class="nav-tab" data-section="zombies">🧟 Zombies</button>
            </div>
            <div class="encyclopedia-content">
                <div class="section active" id="plants-section">
                    <div class="entity-grid" id="plants-grid"></div>
                </div>
                <div class="section" id="zombies-section">
                    <div class="entity-grid" id="zombies-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pause Menu -->
    <div class="pause-overlay" id="pause-overlay" style="display: none;">
        <div class="pause-menu">
            <div class="pause-header">Game Paused</div>
            <div class="pause-content">
                <button class="pause-btn-menu" id="resume-btn">Resume</button>
                <button class="pause-btn-menu" id="guide-btn-pause">📖 Guide</button>
                <button class="pause-btn-menu danger" id="restart-btn">Restart</button>
                <button class="pause-btn-menu success" id="jump-to-wave-btn">Jump to Wave</button>
            </div>
        </div>
    </div>

    <script>
        // Sound Engine
        class SoundEngine {
            constructor() {
                this.audioContext = null;
                this.sounds = new Map();
                this.masterVolume = 0.7;
                this.sfxVolume = 0.8;
                this.musicVolume = 0.5;
                this.initAudio();
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    document.addEventListener('click', () => {
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                    }, { once: true });
                } catch (error) {
                    console.log('Audio not supported');
                }
            }
            
            createTone(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume * this.sfxVolume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
                
                return oscillator;
            }
            
            createNoise(duration, volume = 0.2) {
                if (!this.audioContext) return;
                
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                
                gainNode.gain.setValueAtTime(volume * this.sfxVolume, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                source.buffer = buffer;
                source.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                source.start(this.audioContext.currentTime);
                
                return source;
            }
            
            // Plant Sounds
            plantPlace() { this.createTone(400, 0.1, 'sine', 0.3); setTimeout(() => this.createTone(600, 0.1, 'sine', 0.2), 50); }
            plantUpgrade() { this.createTone(523, 0.1, 'triangle', 0.4); setTimeout(() => this.createTone(659, 0.1, 'triangle', 0.3), 80); setTimeout(() => this.createTone(784, 0.15, 'triangle', 0.2), 160); }
            plantRemove() { this.createTone(600, 0.1, 'sawtooth', 0.3); setTimeout(() => this.createTone(400, 0.15, 'sawtooth', 0.2), 80); }
            peaShoot() { this.createTone(800, 0.08, 'square', 0.15); }
            sunCollect() { this.createTone(523, 0.1, 'sine', 0.25); setTimeout(() => this.createTone(659, 0.1, 'sine', 0.2), 50); setTimeout(() => this.createTone(784, 0.1, 'sine', 0.15), 100); }
            cherryBombFuse() { for (let i = 0; i < 5; i++) { setTimeout(() => { this.createTone(800 + i * 100, 0.1, 'sawtooth', 0.1); }, i * 200); } }
            explosion() { this.createNoise(0.5, 0.6); this.createTone(80, 0.3, 'triangle', 0.4); setTimeout(() => this.createTone(60, 0.2, 'triangle', 0.3), 100); }
            freeze() { for (let i = 0; i < 8; i++) { setTimeout(() => { this.createTone(1200 - i * 150, 0.05, 'sine', 0.1); }, i * 30); } }
            fireBreath() { this.createNoise(0.3, 0.3); this.createTone(200, 0.3, 'sawtooth', 0.2); }
            magnetPull() { this.createTone(300, 0.2, 'sine', 0.2); setTimeout(() => this.createTone(600, 0.1, 'sine', 0.15), 100); }
            spikeDamage() { this.createTone(1000, 0.05, 'square', 0.1); }
            
            // Zombie Sounds
            zombieGroan() { this.createTone(120 + Math.random() * 80, 0.5, 'sawtooth', 0.2); }
            zombieHit() { this.createTone(200 + Math.random() * 100, 0.1, 'square', 0.2); this.createNoise(0.05, 0.1); }
            zombieDeath() { this.createTone(300, 0.2, 'sawtooth', 0.25); setTimeout(() => this.createTone(200, 0.3, 'sawtooth', 0.2), 100); setTimeout(() => this.createTone(100, 0.4, 'sawtooth', 0.15), 200); }
            newspaperRage() { for (let i = 0; i < 10; i++) { setTimeout(() => { this.createTone(150 + Math.random() * 200, 0.1, 'sawtooth', 0.3); }, i * 50); } }
            diggerEmerge() { this.createNoise(0.3, 0.2); this.createTone(180, 0.3, 'triangle', 0.2); }
            balloonPop() { this.createTone(800, 0.05, 'sine', 0.3); this.createNoise(0.1, 0.2); }
            gargantuarStomp() { this.createTone(40, 0.4, 'triangle', 0.5); this.createNoise(0.2, 0.4); }
            impLaunch() { this.createTone(400, 0.1, 'square', 0.2); setTimeout(() => this.createTone(600, 0.1, 'square', 0.15), 50); setTimeout(() => this.createTone(800, 0.1, 'square', 0.1), 100); }
            zomboniMove() { this.createNoise(0.2, 0.15); this.createTone(150, 0.2, 'triangle', 0.1); }
            
            // UI Sounds
            buttonClick() { this.createTone(800, 0.05, 'square', 0.2); }
            buttonHover() { this.createTone(600, 0.03, 'sine', 0.1); }
            cardSelect() { this.createTone(523, 0.08, 'triangle', 0.2); }
            cantAfford() { this.createTone(200, 0.2, 'square', 0.3); setTimeout(() => this.createTone(180, 0.2, 'square', 0.25), 100); }
            waveStart() { this.createTone(523, 0.2, 'triangle', 0.3); setTimeout(() => this.createTone(659, 0.2, 'triangle', 0.25), 150); setTimeout(() => this.createTone(784, 0.3, 'triangle', 0.2), 300); }
            lawnMowerStart() { this.createNoise(0.5, 0.4); this.createTone(120, 0.5, 'sawtooth', 0.3); }
            gameOver() { for (let i = 0; i < 5; i++) { setTimeout(() => { this.createTone(523 - i * 100, 0.3, 'triangle', 0.3); }, i * 200); } }
            
            // Ambient Sounds
            playAmbientLoop() {
                if (!this.audioContext) return;
                
                const playBirds = () => {
                    if (Math.random() < 0.3) {
                        this.createTone(1200 + Math.random() * 800, 0.1, 'sine', 0.05);
                        setTimeout(() => {
                            this.createTone(1000 + Math.random() * 600, 0.08, 'sine', 0.04);
                        }, 100);
                    }
                    setTimeout(playBirds, 3000 + Math.random() * 5000);
                };
                
                const playWind = () => {
                    if (Math.random() < 0.2) {
                        this.createNoise(2, 0.02);
                    }
                    setTimeout(playWind, 8000 + Math.random() * 10000);
                };
                
                playBirds();
                playWind();
            }
        }

        // Main Game Class
        class Game {
            constructor() {
                this.soundEngine = new SoundEngine();
                this.sun = 150;
                this.wave = 1;
                this.score = 0;
                this.selectedPlant = null;
                this.shovelMode = false;
                this.plants = new Map();
                this.zombies = [];
                this.projectiles = [];
                this.gameRunning = true;
                this.gamePaused = false;
                this.waveInProgress = false;
                this.lawnMowers = [true, true, true, true, true];
                this.frozenZombies = new Set();
                this.iceTrails = new Set();
                this.fireEffects = [];
                this.zombieGroanTimer = 0;
                this.pausedAnimationIds = [];
                this.pausedTimeouts = [];
                this.pausedIntervals = [];
                
                this.plantDescriptions = {
                    peashooter: "Basic offensive plant that shoots peas at zombies in its lane. Essential for early defense.",
                    sunflower: "Produces sun currency needed to plant other plants. Plant early and protect them!",
                    wallnut: "Defensive plant with high health. Use to protect other plants from zombie attacks.",
                    cherrybomb: "Explosive plant that detonates after 1 second, dealing massive area damage.",
                    repeater: "Advanced peashooter that fires peas twice as fast for rapid damage output.",
                    iceshroom: "Freezes all zombies on screen periodically, slowing their advance significantly.",
                    snapdragon: "Breathes fire at close-range zombies, dealing continuous damage over time.",
                    magnetshroom: "Removes metal armor from bucket and cone zombies, reducing their health.",
                    spikeweed: "Ground plant that damages zombies walking over it. Doesn't block flying zombies.",
                    torchwood: "Support plant that increases damage of projectiles passing through it by percentage.",
                    potatomine: "Underground explosive that detonates when zombies step on it. Cheap but single-use.",
                    cactus: "Versatile plant that can target both ground and flying zombies with needle projectiles.",
                    chomper: "Devours zombies whole but needs time to chew. Vulnerable while eating.",
                    lightningreed: "Shoots chain lightning that jumps between nearby zombies for area damage.",
                    pumpkin: "Protective shell that can be placed over other plants to give them extra armor."
                };
                
                this.zombieDescriptions = {
                    basic: "Standard zombie with average health and speed. The most common threat.",
                    cone: "Zombie wearing a traffic cone for extra protection. Takes more hits to defeat.",
                    bucket: "Heavily armored zombie with a metal bucket. Very durable but slow.",
                    football: "Fast-moving zombie in sports gear. High health and increased movement speed.",
                    newspaper: "Carries newspaper shield. Becomes enraged and faster when shield is destroyed.",
                    digger: "Travels underground to bypass most plants, emerging near your house.",
                    balloon: "Flies over ground plants. Can only be hit by lobbed projectiles.",
                    gargantuar: "Massive boss zombie that crushes plants instantly. Throws Imp when damaged.",
                    imp: "Small, fast zombie thrown by Gargantuar. Low health but high speed.",
                    zomboni: "Zombie ice machine that creates ice trails, blocking plant placement.",
                    polevault: "Athletic zombie that pole vaults over the first plant it encounters.",
                    dolphinrider: "Zombie riding a dolphin for incredible speed through your defenses.",
                    bungee: "Drops from the sky to steal your plants! Retreats quickly after theft.",
                    jackinbox: "Explosive zombie that detonates when defeated, damaging nearby plants.",
                    catapult: "Throws basketballs over your plants, targeting backline defenses."
                };
                
                this.plantTypes = {
                    peashooter: { 
                        cost: 100, 
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, damage: 20, fireRate: 1000, emoji: '🌱' },
                            2: { health: 450, damage: 35, fireRate: 800, emoji: '🌿' },
                            3: { health: 600, damage: 55, fireRate: 600, emoji: '👯' }
                        }
                    },
                    sunflower: { 
                        cost: 50,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, sunProduction: 25, sunRate: 6667, emoji: '🌻' },
                            2: { health: 450, sunProduction: 40, sunRate: 5000, emoji: '☀️' },
                            3: { health: 600, sunProduction: 60, sunRate: 4000, emoji: '🌞' }
                        }
                    },
                    wallnut: { 
                        cost: 50,
                        maxLevel: 3,
                        levels: {
                            1: { health: 4000, emoji: '🥜' },
                            2: { health: 7000, emoji: '🛡️' },
                            3: { health: 12000, emoji: '🏰' }
                        }
                    },
                    cherrybomb: { 
                        cost: 150,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, explosionDamage: 1800, explosionRadius: 100, emoji: '🍒' },
                            2: { health: 450, explosionDamage: 2700, explosionRadius: 120, emoji: '💣' },
                            3: { health: 600, explosionDamage: 4000, explosionRadius: 150, emoji: '🌋' }
                        }
                    },
                    repeater: { 
                        cost: 200,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, damage: 20, fireRate: 500, emoji: '🫛' },
                            2: { health: 450, damage: 35, fireRate: 350, emoji: '💥' },
                            3: { health: 600, damage: 55, fireRate: 250, emoji: '☄️' }
                        }
                    },
                    iceshroom: {
                        cost: 75,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, freezeDuration: 5000, cooldown: 30000, emoji: '🧊' },
                            2: { health: 450, freezeDuration: 7000, cooldown: 25000, emoji: '❄️' },
                            3: { health: 600, freezeDuration: 10000, cooldown: 20000, emoji: '🥶' }
                        }
                    },
                    snapdragon: {
                        cost: 175,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, damage: 40, fireRate: 1500, range: 150, emoji: '🐉' },
                            2: { health: 450, damage: 60, fireRate: 1200, range: 200, emoji: '🔥' },
                            3: { health: 600, damage: 90, fireRate: 1000, range: 250, emoji: '🎇' }
                        }
                    },
                    magnetshroom: {
                        cost: 100,
                        maxLevel: 3,
                        nightPlant: true,
                        levels: {
                            1: { health: 300, range: 200, cooldown: 8000, emoji: '🧲' },
                            2: { health: 450, range: 250, cooldown: 6000, emoji: '💫' },
                            3: { health: 600, range: 300, cooldown: 4000, emoji: '🌌' }
                        }
                    },
                    spikeweed: {
                        cost: 100,
                        maxLevel: 3,
                        isGround: true,
                        levels: {
                            1: { health: 300, damage: 20, emoji: '🌵' },
                            2: { health: 450, damage: 35, emoji: '🔪' },
                            3: { health: 600, damage: 55, emoji: '🗡️' }
                        }
                    },
                    torchwood: {
                        cost: 125,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, damageBoost: 0.5, emoji: '🔥' },
                            2: { health: 450, damageBoost: 0.75, emoji: '🔥' },
                            3: { health: 600, damageBoost: 1.0, emoji: '🌋' }
                        }
                    },
                    potatomine: {
                        cost: 25,
                        maxLevel: 3,
                        isGround: true,
                        levels: {
                            1: { health: 300, explosionDamage: 1800, emoji: '🥔' },
                            2: { health: 450, explosionDamage: 2700, emoji: '💣' },
                            3: { health: 600, explosionDamage: 4000, emoji: '💥' }
                        }
                    },
                    cactus: {
                        cost: 125,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, damage: 20, fireRate: 1200, range: 300, emoji: '🌵' },
                            2: { health: 450, damage: 35, fireRate: 1000, range: 350, emoji: '🏹' },
                            3: { health: 600, damage: 55, fireRate: 800, range: 400, emoji: '🎯' }
                        }
                    },
                    chomper: {
                        cost: 150,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, chewTime: 3000, emoji: '🪴' },
                            2: { health: 450, chewTime: 2500, emoji: '🦕' },
                            3: { health: 600, chewTime: 2000, emoji: '🐲' }
                        }
                    },
                    lightningreed: {
                        cost: 175,
                        maxLevel: 3,
                        levels: {
                            1: { health: 300, damage: 25, fireRate: 2000, chainCount: 2, emoji: '⚡' },
                            2: { health: 450, damage: 40, fireRate: 1800, chainCount: 3, emoji: '🌩️' },
                            3: { health: 600, damage: 60, fireRate: 1500, chainCount: 4, emoji: '⛈️' }
                        }
                    },
                    pumpkin: {
                        cost: 75,
                        maxLevel: 3,
                        isShell: true,
                        levels: {
                            1: { health: 4000, emoji: '🎃' },
                            2: { health: 7000, emoji: '🎃' },
                            3: { health: 12000, emoji: '👻' }
                        }
                    }
                };
                
                this.zombieTypes = {
                    basic: { health: 200, speed: 20, damage: 100, emoji: '🧟' },
                    cone: { health: 640, speed: 20, damage: 100, emoji: '🧟‍♂️', hasHelmet: true },
                    bucket: { health: 1300, speed: 20, damage: 100, emoji: '🧟‍♀️', hasBucket: true },
                    football: { health: 1600, speed: 40, damage: 100, emoji: '🏈', hasHelmet: true },
                    newspaper: { health: 200, speed: 20, damage: 100, emoji: '📰', hasNewspaper: true, enragedSpeed: 60 },
                    digger: { health: 200, speed: 30, damage: 100, emoji: '⛏️', underground: true },
                    balloon: { health: 200, speed: 25, damage: 100, emoji: '🎈', flying: true },
                    gargantuar: { health: 3000, speed: 15, damage: 300, emoji: '👹', isBoss: true, crushes: true },
                    imp: { health: 100, speed: 50, damage: 50, emoji: '👺', small: true },
                    zomboni: { health: 1300, speed: 25, damage: 100, emoji: '🧊', createsIce: true },
                    polevault: { health: 340, speed: 25, damage: 100, emoji: '🤸', vaults: true },
                    dolphinrider: { health: 430, speed: 50, damage: 100, emoji: '🐬', aquatic: true },
                    bungee: { health: 270, speed: 0, damage: 0, emoji: '🪂', stealsPlants: true, flying: true },
                    jackinbox: { health: 270, speed: 20, damage: 100, emoji: '🃏', explosive: true },
                    catapult: { health: 850, speed: 20, damage: 100, emoji: '🏀', ranged: true }
                };
                
                this.initializeGame();
                this.setupEncyclopedia();
                
                setTimeout(() => {
                    this.soundEngine.playAmbientLoop();
                }, 2000);
            }
            
            initializeGame() {
                this.createGrid();
                this.setupEventListeners();
                this.setupPauseMenu();
                this.startGameLoop();
                this.scheduleWave();
            }

            // Helper methods for proper positioning
            getLaneCenterY(row) {
                // Game board starts after 80px UI panel
                // Grid has 20px padding, so content starts at 80 + 20 = 100px from top
                // Available height for 5 rows = window.innerHeight - 80 (UI) - 40 (top+bottom padding)
                const availableHeight = window.innerHeight - 80 - 40;
                const laneHeight = availableHeight / 5;
                return 100 + (row * laneHeight) + (laneHeight / 2);
            }

            getLaneCenterX(col) {
                // Grid has 20px padding on left and right
                // Available width for 9 columns = window.innerWidth - 40 (left+right padding)
                const availableWidth = window.innerWidth - 40;
                const cellWidth = availableWidth / 9;
                return 20 + (col * cellWidth) + (cellWidth / 2);
            }

            getLaneWidth() {
                const availableWidth = window.innerWidth - 40;
                return availableWidth / 9;
            }

            getLaneHeight() {
                const availableHeight = window.innerHeight - 80 - 40;
                return availableHeight / 5;
            }

            setupPauseMenu() {
                // Pause button
                document.getElementById('pause-btn').addEventListener('click', () => {
                    this.togglePause();
                });

                // Resume button
                document.getElementById('resume-btn').addEventListener('click', () => {
                    this.togglePause();
                });

                // Restart button
                document.getElementById('restart-btn').addEventListener('click', () => {
                    this.restartGame();
                });

                // Jump to wave button
                document.getElementById('jump-to-wave-btn').addEventListener('click', () => {
                    this.showWaveJumpMenu();
                });

                // Guide button in pause menu
                document.getElementById('guide-btn-pause').addEventListener('click', () => {
                    document.getElementById('pause-overlay').style.display = 'none';
                    this.openEncyclopedia();
                });

                // ESC key for pause
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.togglePause();
                    }
                });

                // Close pause menu on overlay click
                document.getElementById('pause-overlay').addEventListener('click', (e) => {
                    if (e.target.id === 'pause-overlay') {
                        this.togglePause();
                    }
                });
            }

            togglePause() {
                this.gamePaused = !this.gamePaused;
                const pauseOverlay = document.getElementById('pause-overlay');
                
                if (this.gamePaused) {
                    pauseOverlay.style.display = 'flex';
                    this.showPausedIndicator();
                    this.soundEngine.buttonClick();
                } else {
                    pauseOverlay.style.display = 'none';
                    this.hidePausedIndicator();
                    this.soundEngine.buttonClick();
                }
            }

            showPausedIndicator() {
                if (document.getElementById('paused-indicator')) return;
                
                const indicator = document.createElement('div');
                indicator.className = 'paused-indicator';
                indicator.id = 'paused-indicator';
                indicator.textContent = 'GAME PAUSED';
                document.querySelector('.game-board').appendChild(indicator);
            }

            hidePausedIndicator() {
                const indicator = document.getElementById('paused-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            restartGame() {
                this.soundEngine.buttonClick();
                
                // Clear all game elements
                this.clearGameState();
                
                // Reset game variables
                this.sun = 150;
                this.wave = 1;
                this.score = 0;
                this.selectedPlant = null;
                this.shovelMode = false;
                this.waveInProgress = false;
                this.lawnMowers = [true, true, true, true, true];
                this.gamePaused = false;
                
                // Hide pause menu
                document.getElementById('pause-overlay').style.display = 'none';
                this.hidePausedIndicator();
                
                // Recreate game elements
                this.createGrid();
                this.updateUI();
                this.scheduleWave();
            }

            showWaveJumpMenu() {
                const pauseContent = document.querySelector('.pause-content');
                
                // Check if wave jump section already exists
                if (document.getElementById('wave-jump-section')) {
                    document.getElementById('wave-jump-section').remove();
                    return;
                }
                
                const waveJumpSection = document.createElement('div');
                waveJumpSection.className = 'wave-jump-section';
                waveJumpSection.id = 'wave-jump-section';
                
                waveJumpSection.innerHTML = `
                    <div class="wave-jump-title">🌊 Jump to Wave</div>
                    <div class="wave-input-group">
                        <label class="wave-input-label">Wave:</label>
                        <input type="number" class="wave-input" id="wave-input" min="1" max="50" value="${this.wave}">
                    </div>
                    <input type="range" class="wave-slider" id="wave-slider" min="1" max="50" value="${this.wave}">
                    <div class="wave-info">
                        <span>Wave 1</span>
                        <span>Current: ${this.wave}</span>
                        <span>Wave 50</span>
                    </div>
                    <button class="pause-btn-menu success" id="confirm-wave-jump">Jump to Wave <span id="selected-wave">${this.wave}</span></button>
                    <button class="pause-btn-menu" id="cancel-wave-jump">Cancel</button>
                `;
                
                pauseContent.appendChild(waveJumpSection);
                
                // Wave input and slider synchronization
                const waveInput = document.getElementById('wave-input');
                const waveSlider = document.getElementById('wave-slider');
                const selectedWaveSpan = document.getElementById('selected-wave');
                
                const updateWaveSelection = (value) => {
                    waveInput.value = value;
                    waveSlider.value = value;
                    selectedWaveSpan.textContent = value;
                };
                
                waveInput.addEventListener('input', (e) => {
                    const value = Math.max(1, Math.min(50, parseInt(e.target.value) || 1));
                    updateWaveSelection(value);
                });
                
                waveSlider.addEventListener('input', (e) => {
                    updateWaveSelection(e.target.value);
                });
                
                // Confirm wave jump
                document.getElementById('confirm-wave-jump').addEventListener('click', () => {
                    const targetWave = parseInt(waveInput.value);
                    this.jumpToWave(targetWave);
                });
                
                // Cancel wave jump
                document.getElementById('cancel-wave-jump').addEventListener('click', () => {
                    waveJumpSection.remove();
                    this.soundEngine.buttonClick();
                });
                
                this.soundEngine.buttonClick();
            }

            jumpToWave(targetWave) {
                this.soundEngine.waveStart();
                
                // Clear current game state but preserve plants
                this.clearGameStateExceptPlants();
                
                // Set new wave
                this.wave = Math.max(1, Math.min(50, targetWave));
                this.waveInProgress = false;
                this.gamePaused = false;
                
                // Give appropriate sun for the wave (but don't reduce if higher)
                const newSunAmount = Math.max(150, 100 + (this.wave - 1) * 25);
                this.sun = Math.max(this.sun, newSunAmount);
                
                // Hide pause menu
                document.getElementById('pause-overlay').style.display = 'none';
                this.hidePausedIndicator();
                
                // Update UI and start new wave
                this.updateUI();
                this.scheduleWave();
            }

            clearGameStateExceptPlants() {
                // Clear all zombies
                this.zombies.forEach(zombie => {
                    if (zombie.element) zombie.element.remove();
                });
                this.zombies = [];
                
                // Clear all projectiles
                this.projectiles.forEach(projectile => {
                    if (projectile.element) projectile.element.remove();
                });
                this.projectiles = [];
                
                // Clear ice trails
                this.iceTrails.clear();
                document.querySelectorAll('.ice-trail').forEach(trail => trail.remove());
                
                // Clear frozen zombies
                this.frozenZombies.clear();
                
                // Clear other effects
                document.querySelectorAll('.explosion, .damage-text, .fire-effect, .upgrade-indicator, .wave-indicator').forEach(el => el.remove());
                
                // Reset lawn mowers
                document.querySelectorAll('.mower').forEach(mower => mower.remove());
                this.createLawnMowers();
                
                // Reset selected plant and shovel mode
                this.selectedPlant = null;
                this.shovelMode = false;
                document.querySelectorAll('.plant-card').forEach(card => card.classList.remove('selected'));
                document.getElementById('shovel-btn').classList.remove('active');
                document.querySelector('.game-board').classList.remove('shovel-mode');
            }

            clearGameState() {
                // Clear all zombies
                this.zombies.forEach(zombie => {
                    if (zombie.element) zombie.element.remove();
                });
                this.zombies = [];
                
                // Clear all projectiles
                this.projectiles.forEach(projectile => {
                    if (projectile.element) projectile.element.remove();
                });
                this.projectiles = [];
                
                // Clear all plants
                this.plants.forEach(plant => {
                    if (plant.element) plant.element.remove();
                });
                this.plants.clear();
                
                // Clear ice trails
                this.iceTrails.clear();
                document.querySelectorAll('.ice-trail').forEach(trail => trail.remove());
                
                // Clear frozen zombies
                this.frozenZombies.clear();
                
                // Clear other effects
                document.querySelectorAll('.explosion, .damage-text, .fire-effect, .upgrade-indicator, .wave-indicator').forEach(el => el.remove());
                
                // Reset lawn mowers
                document.querySelectorAll('.mower').forEach(mower => mower.remove());
                this.createLawnMowers();
                
                // Reset selected plant and shovel mode
                this.selectedPlant = null;
                this.shovelMode = false;
                document.querySelectorAll('.plant-card').forEach(card => card.classList.remove('selected'));
                document.getElementById('shovel-btn').classList.remove('active');
                document.querySelector('.game-board').classList.remove('shovel-mode');
            }
            
            createGrid() {
                const grid = document.getElementById('grid');
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        grid.appendChild(cell);
                    }
                }
                this.createLawnMowers();
            }
            
            createLawnMowers() {
                for (let row = 0; row < 5; row++) {
                    const mower = document.createElement('div');
                    mower.className = 'mower';
                    mower.textContent = '🚜';
                    mower.style.top = (100 + row * (window.innerHeight - 180) / 5 + 15) + 'px';
                    mower.id = `mower-${row}`;
                    document.querySelector('.game-board').appendChild(mower);
                }
            }
            
            setupEventListeners() {
                // Encyclopedia button
                document.getElementById('encyclopedia-btn').addEventListener('click', () => {
                    this.openEncyclopedia();
                });

                // Shovel tool event listener
                document.getElementById('shovel-btn').addEventListener('click', () => {
                    this.toggleShovelMode();
                });

                document.querySelectorAll('.plant-card').forEach(card => {
                    card.addEventListener('mouseenter', () => {
                        this.soundEngine.buttonHover();
                    });
                    
                    card.addEventListener('click', (e) => {
                        const plantType = e.currentTarget.dataset.plant;
                        if (this.sun >= this.plantTypes[plantType].cost) {
                            this.soundEngine.cardSelect();
                            this.selectPlant(plantType);
                        } else {
                            this.soundEngine.cantAfford();
                        }
                    });
                });
                
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.addEventListener('click', (e) => {
                        if (this.shovelMode) {
                            this.removePlant(e.currentTarget);
                        } else if (this.selectedPlant) {
                            this.placePlant(e.currentTarget);
                        }
                    });

                    // Visual feedback for shovel mode
                    cell.addEventListener('mouseenter', () => {
                        if (this.shovelMode) {
                            const row = parseInt(cell.dataset.row);
                            const col = parseInt(cell.dataset.col);
                            const key = `${row},${col}`;
                            const plant = this.plants.get(key);
                            if (plant) {
                                cell.classList.add('removable');
                            }
                        }
                    });

                    cell.addEventListener('mouseleave', () => {
                        cell.classList.remove('removable');
                    });
                });
            }
            
            toggleShovelMode() {
                this.shovelMode = !this.shovelMode;
                const shovelBtn = document.getElementById('shovel-btn');
                const gameBoard = document.querySelector('.game-board');
                
                if (this.shovelMode) {
                    // Activate shovel mode
                    shovelBtn.classList.add('active');
                    gameBoard.classList.add('shovel-mode');
                    this.selectedPlant = null;
                    
                    // Deselect any selected plant cards
                    document.querySelectorAll('.plant-card').forEach(card => {
                        card.classList.remove('selected');
                    });
                    
                    this.soundEngine.cardSelect();
                } else {
                    // Deactivate shovel mode
                    shovelBtn.classList.remove('active');
                    gameBoard.classList.remove('shovel-mode');
                    this.soundEngine.buttonClick();
                }
            }

            selectPlant(type) {
                // Deactivate shovel mode when selecting a plant
                if (this.shovelMode) {
                    this.toggleShovelMode();
                }
                
                document.querySelectorAll('.plant-card').forEach(card => {
                    card.classList.remove('selected');
                });
                document.querySelector(`[data-plant="${type}"]`).classList.add('selected');
                this.selectedPlant = type;
            }

            removePlant(cell) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const key = `${row},${col}`;
                const plant = this.plants.get(key);
                
                if (plant) {
                    // Remove plant element from DOM
                    plant.element.remove();
                    
                    // Remove plant from plants map
                    this.plants.delete(key);
                    
                    // Play removal sound
                    this.soundEngine.plantRemove();
                    
                    // Show removal indicator
                    this.showUpgradeIndicator(cell, 'REMOVED!');
                    
                    // Get small sun refund (25% of original cost)
                    const plantType = this.plantTypes[plant.type];
                    const refund = Math.floor(plantType.cost * 0.25);
                    this.sun += refund;
                    this.updateUI();
                    
                    // Show refund indicator
                    setTimeout(() => {
                        this.showUpgradeIndicator(cell, `+${refund} ☀️`);
                    }, 500);
                }
            }

            setupEncyclopedia() {
                // Close encyclopedia button
                document.getElementById('close-encyclopedia').addEventListener('click', () => {
                    this.closeEncyclopedia();
                });

                // Close on overlay click
                document.getElementById('encyclopedia-overlay').addEventListener('click', (e) => {
                    if (e.target.id === 'encyclopedia-overlay') {
                        this.closeEncyclopedia();
                    }
                });

                // Tab navigation
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchEncyclopediaTab(e.target.dataset.section);
                    });
                });

                this.populateEncyclopedia();
            }

            openEncyclopedia() {
                document.getElementById('encyclopedia-overlay').style.display = 'flex';
                this.soundEngine.buttonClick();
            }

            closeEncyclopedia() {
                document.getElementById('encyclopedia-overlay').style.display = 'none';
                this.soundEngine.buttonClick();
            }

            switchEncyclopediaTab(section) {
                // Update tab appearance
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-section="${section}"]`).classList.add('active');

                // Update section visibility
                document.querySelectorAll('.section').forEach(sec => {
                    sec.classList.remove('active');
                });
                document.getElementById(`${section}-section`).classList.add('active');

                this.soundEngine.buttonHover();
            }

            populateEncyclopedia() {
                this.populatePlantsSection();
                this.populateZombiesSection();
            }

            populatePlantsSection() {
                const plantsGrid = document.getElementById('plants-grid');
                plantsGrid.innerHTML = '';

                Object.entries(this.plantTypes).forEach(([plantKey, plantData]) => {
                    const card = document.createElement('div');
                    card.className = 'entity-card';
                    
                    const level1 = plantData.levels[1];
                    const capitalizedName = plantKey.charAt(0).toUpperCase() + plantKey.slice(1);
                    
                    let statsHtml = '';
                    if (level1.damage) statsHtml += `<span class="stat-badge">Damage: ${level1.damage}</span>`;
                    if (level1.health) statsHtml += `<span class="stat-badge">Health: ${level1.health}</span>`;
                    if (level1.sunProduction) statsHtml += `<span class="stat-badge">Sun: +${level1.sunProduction}</span>`;
                    if (level1.explosionDamage) statsHtml += `<span class="stat-badge">Explosion: ${level1.explosionDamage}</span>`;
                    if (level1.range) statsHtml += `<span class="stat-badge">Range: ${level1.range}px</span>`;
                    if (plantData.isGround) statsHtml += `<span class="stat-badge">Ground Plant</span>`;
                    
                    let levelProgressionHtml = '<div class="level-progression"><strong>Level Progression:</strong>';
                    for (let level = 1; level <= plantData.maxLevel; level++) {
                        const levelData = plantData.levels[level];
                        levelProgressionHtml += `
                            <div class="level-row">
                                <span class="level-emoji">${levelData.emoji}</span>
                                <span>Level ${level}</span>
                            </div>`;
                    }
                    levelProgressionHtml += '</div>';
                    
                    card.innerHTML = `
                        <div class="entity-header">
                            <div class="entity-emoji">${level1.emoji}</div>
                            <div>
                                <div class="entity-name">${capitalizedName}</div>
                                <div class="entity-cost">☀️ ${plantData.cost} sun</div>
                            </div>
                        </div>
                        <div class="entity-description">${this.plantDescriptions[plantKey]}</div>
                        <div class="entity-stats">${statsHtml}</div>
                        ${levelProgressionHtml}
                    `;
                    
                    plantsGrid.appendChild(card);
                });
            }

            populateZombiesSection() {
                const zombiesGrid = document.getElementById('zombies-grid');
                zombiesGrid.innerHTML = '';

                Object.entries(this.zombieTypes).forEach(([zombieKey, zombieData]) => {
                    const card = document.createElement('div');
                    card.className = 'entity-card';
                    
                    const capitalizedName = zombieKey.charAt(0).toUpperCase() + zombieKey.slice(1);
                    
                    let statsHtml = '';
                    statsHtml += `<span class="stat-badge">Health: ${zombieData.health}</span>`;
                    statsHtml += `<span class="stat-badge">Speed: ${zombieData.speed}</span>`;
                    statsHtml += `<span class="stat-badge">Damage: ${zombieData.damage}</span>`;
                    
                    if (zombieData.hasHelmet) statsHtml += `<span class="stat-badge">Helmet Protection</span>`;
                    if (zombieData.hasBucket) statsHtml += `<span class="stat-badge">Bucket Armor</span>`;
                    if (zombieData.underground) statsHtml += `<span class="stat-badge">Underground</span>`;
                    if (zombieData.flying) statsHtml += `<span class="stat-badge">Flying</span>`;
                    if (zombieData.isBoss) statsHtml += `<span class="stat-badge">Boss</span>`;
                    if (zombieData.crushes) statsHtml += `<span class="stat-badge">Crushes Plants</span>`;
                    if (zombieData.createsIce) statsHtml += `<span class="stat-badge">Creates Ice</span>`;
                    
                    card.innerHTML = `
                        <div class="entity-header">
                            <div class="entity-emoji">${zombieData.emoji}</div>
                            <div>
                                <div class="entity-name">${capitalizedName} Zombie</div>
                                <div class="entity-cost">Wave ${this.getZombieWaveAppearance(zombieKey)}+</div>
                            </div>
                        </div>
                        <div class="entity-description">${this.zombieDescriptions[zombieKey]}</div>
                        <div class="entity-stats">${statsHtml}</div>
                    `;
                    
                    zombiesGrid.appendChild(card);
                });
            }

            getZombieWaveAppearance(zombieType) {
                switch(zombieType) {
                    case 'basic': return 1;
                    case 'cone': return 3;
                    case 'polevault': return 4;
                    case 'newspaper': return 5;
                    case 'dolphinrider': return 5;
                    case 'bucket': return 6;
                    case 'digger': return 6;
                    case 'jackinbox': return 7;
                    case 'football': return 8;
                    case 'balloon': return 8;
                    case 'zomboni': return 10;
                    case 'bungee': return 10;
                    case 'catapult': return 12;
                    case 'gargantuar': return 15;
                    case 'imp': return 15;
                    default: return 1;
                }
            }
            
            placePlant(cell) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const key = `${row},${col}`;
                const existingPlant = this.plants.get(key);
                
                const plantType = this.plantTypes[this.selectedPlant];
                if (this.sun < plantType.cost) return;
                
                if (this.iceTrails.has(key) && !plantType.isGround) {
                    this.soundEngine.cantAfford();
                    this.showUpgradeIndicator(cell, 'ICE BLOCKED');
                    return;
                }
                
                if (existingPlant && existingPlant.type === this.selectedPlant) {
                    // Prevent upgrading single-use plants like cherry bomb and potato mine
                    if (this.selectedPlant === 'cherrybomb' || this.selectedPlant === 'potatomine') {
                        this.soundEngine.cantAfford();
                        this.showUpgradeIndicator(cell, 'SINGLE USE');
                        return;
                    }
                    
                    if (existingPlant.level >= plantType.maxLevel) {
                        this.soundEngine.cantAfford();
                        this.showUpgradeIndicator(cell, 'MAX LEVEL');
                        return;
                    }
                    this.upgradePlant(existingPlant, key, cell);
                    return;
                }
                
                if (existingPlant && !(plantType.isGround && !existingPlant.isGround) && !(plantType.isShell && !existingPlant.isShell)) return;
                
                this.sun -= plantType.cost;
                this.updateUI();
                this.soundEngine.plantPlace();
                
                const level = 1;
                const levelStats = plantType.levels[level];
                const plant = {
                    type: this.selectedPlant,
                    level: level,
                    row: row,
                    col: col,
                    health: levelStats.health,
                    maxHealth: levelStats.health,
                    lastFire: 0,
                    lastSun: 0,
                    lastFreeze: 0,
                    lastMagnet: 0,
                    isGround: plantType.isGround || false,
                    element: this.createPlantElement(levelStats.emoji, level, cell)
                };
                
                this.plants.set(key, plant);
                
                if (this.selectedPlant === 'cherrybomb') {
                    this.soundEngine.cherryBombFuse();
                    setTimeout(() => this.explodeCherryBomb(plant), 1000);
                }
                
                this.selectedPlant = null;
                document.querySelectorAll('.plant-card').forEach(card => {
                    card.classList.remove('selected');
                });
            }
            
            upgradePlant(plant, key, cell) {
                const plantType = this.plantTypes[plant.type];
                const newLevel = plant.level + 1;
                const newStats = plantType.levels[newLevel];
                
                this.sun -= plantType.cost;
                this.updateUI();
                this.soundEngine.plantUpgrade();
                
                plant.level = newLevel;
                plant.maxHealth = newStats.health;
                plant.health = Math.min(plant.health + (newStats.health - plantType.levels[newLevel - 1].health), newStats.health);
                
                plant.element.remove();
                plant.element = this.createPlantElement(newStats.emoji, newLevel, cell);
                
                this.showUpgradeIndicator(cell, `LEVEL ${newLevel}!`);
                this.plants.set(key, plant);
                
                this.selectedPlant = null;
                document.querySelectorAll('.plant-card').forEach(card => {
                    card.classList.remove('selected');
                });
            }
            
            showUpgradeIndicator(cell, text) {
                const indicator = document.createElement('div');
                indicator.className = 'upgrade-indicator';
                indicator.textContent = text;
                cell.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 1500);
            }
            
            createPlantElement(emoji, level, cell) {
                const plantEl = document.createElement('div');
                plantEl.className = 'plant';
                plantEl.innerHTML = `
                    ${emoji}
                    <div class="plant-level">${level}</div>
                `;
                cell.appendChild(plantEl);
                return plantEl;
            }
            
            scheduleWave() {
                if (!this.gameRunning) return;
                
                this.showWaveIndicator();
                
                const waveDelay = Math.max(3000 - this.wave * 100, 1500);
                
                const scheduleTimeout = () => {
                    if (this.gamePaused) {
                        setTimeout(scheduleTimeout, 100);
                        return;
                    }
                    
                    this.waveInProgress = true;
                    this.spawnWave();
                };
                
                setTimeout(scheduleTimeout, waveDelay);
            }
            
            showWaveIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'wave-indicator';
                
                let waveText = `Wave ${this.wave}`;
                if (this.wave >= 10) waveText += ' - BOSS WAVE!';
                else if (this.wave >= 6) waveText += ' - Armored Zombies!';
                else if (this.wave >= 3) waveText += ' - Stronger Zombies!';
                
                indicator.textContent = waveText;
                document.querySelector('.game-board').appendChild(indicator);
                
                this.soundEngine.waveStart();
                
                setTimeout(() => indicator.remove(), 2000);
            }
            
            spawnWave() {
                const zombieCount = Math.min(5 + this.wave * 3, 25);
                const spawnDelay = Math.max(2500 - this.wave * 150, 800);
                
                let spawned = 0;
                const spawnInterval = setInterval(() => {
                    if (!this.gameRunning) {
                        clearInterval(spawnInterval);
                        return;
                    }
                    
                    if (this.gamePaused) {
                        return; // Don't spawn while paused
                    }
                    
                    if (spawned >= zombieCount) {
                        clearInterval(spawnInterval);
                        this.checkWaveComplete();
                        return;
                    }
                    
                    this.spawnZombie();
                    spawned++;
                }, spawnDelay);
            }
            
            checkWaveComplete() {
                const checkInterval = setInterval(() => {
                    if (!this.gameRunning) {
                        clearInterval(checkInterval);
                        return;
                    }
                    
                    if (this.gamePaused) {
                        return; // Don't check wave completion while paused
                    }
                    
                    if (this.zombies.length === 0) {
                        clearInterval(checkInterval);
                        this.wave++;
                        this.waveInProgress = false;
                        
                        const nextWaveDelay = () => {
                            if (this.gamePaused) {
                                setTimeout(nextWaveDelay, 100);
                                return;
                            }
                            
                            if (this.gameRunning) {
                                this.scheduleWave();
                            }
                        };
                        
                        setTimeout(nextWaveDelay, 3000);
                    }
                }, 500);
            }
            
            spawnZombie() {
                const row = Math.floor(Math.random() * 5);
                let type = 'basic';
                
                if (this.wave >= 2) {
                    const rand = Math.random();
                    if (this.wave >= 15 && rand < 0.05) type = 'gargantuar';
                    else if (this.wave >= 12 && rand < 0.08) type = 'catapult';
                    else if (this.wave >= 10 && rand < 0.1) type = 'zomboni';
                    else if (this.wave >= 10 && rand < 0.15) type = 'bungee';
                    else if (this.wave >= 8 && rand < 0.1) type = 'balloon';
                    else if (this.wave >= 8 && rand < 0.2) type = 'football';
                    else if (this.wave >= 7 && rand < 0.15) type = 'jackinbox';
                    else if (this.wave >= 6 && rand < 0.2) type = 'digger';
                    else if (this.wave >= 6 && rand < 0.35) type = 'bucket';
                    else if (this.wave >= 5 && rand < 0.25) type = 'dolphinrider';
                    else if (this.wave >= 5 && rand < 0.4) type = 'newspaper';
                    else if (this.wave >= 4 && rand < 0.3) type = 'polevault';
                    else if (this.wave >= 3 && rand < 0.5) type = 'cone';
                }
                
                const zombieData = this.zombieTypes[type];
                const healthMultiplier = 1 + (this.wave - 1) * 0.1;
                const speedMultiplier = 1 + (this.wave - 1) * 0.05;
                
                const zombie = {
                    type: type,
                    row: row,
                    x: window.innerWidth - 50,
                    y: 100 + row * (window.innerHeight - 180) / 5,
                    health: zombieData.health * healthMultiplier,
                    maxHealth: zombieData.health * healthMultiplier,
                    speed: zombieData.speed * speedMultiplier * (0.8 + Math.random() * 0.4),
                    damage: zombieData.damage,
                    eating: false,
                    hasNewspaper: zombieData.hasNewspaper || false,
                    hasBucket: zombieData.hasBucket || false,
                    hasHelmet: zombieData.hasHelmet || false,
                    underground: zombieData.underground || false,
                    flying: zombieData.flying || false,
                    isBoss: zombieData.isBoss || false,
                    crushes: zombieData.crushes || false,
                    createsIce: zombieData.createsIce || false,
                    enraged: false,
                    element: this.createZombieElement(zombieData.emoji)
                };
                
                zombie.element.style.left = zombie.x + 'px';
                zombie.element.style.top = zombie.y + 'px';
                
                if (zombie.underground) zombie.element.classList.add('underground');
                if (zombie.flying) zombie.element.classList.add('flying');
                if (zombie.isBoss) zombie.element.style.transform = 'scale(1.5)';
                
                this.zombies.push(zombie);
            }
            
            createZombieElement(emoji) {
                const zombieEl = document.createElement('div');
                zombieEl.className = 'zombie';
                zombieEl.innerHTML = `
                    ${emoji}
                    <div class="health-bar">
                        <div class="health-fill"></div>
                    </div>
                `;
                document.querySelector('.game-board').appendChild(zombieEl);
                return zombieEl;
            }
            
            updatePlants() {
                const now = Date.now();
                
                this.plants.forEach(plant => {
                    const plantType = this.plantTypes[plant.type];
                    const levelStats = plantType.levels[plant.level];
                    
                    if (plant.type === 'sunflower' && now - plant.lastSun >= levelStats.sunRate) {
                        this.sun += levelStats.sunProduction;
                        plant.lastSun = now;
                        this.soundEngine.sunCollect();
                    }
                    
                    if ((plant.type === 'peashooter' || plant.type === 'repeater') && 
                        now - plant.lastFire >= levelStats.fireRate) {
                        
                        const zombie = this.zombies.find(z => z.row === plant.row && z.x > plant.col * (window.innerWidth - 40) / 9);
                        if (zombie) {
                            this.firePea(plant, levelStats.damage);
                            plant.lastFire = now;
                        }
                    }
                    
                    if (plant.type === 'iceshroom' && now - plant.lastFreeze >= levelStats.cooldown) {
                        if (this.zombies.length > 0) {
                            this.freezeAllZombies(levelStats.freezeDuration);
                            plant.lastFreeze = now;
                        }
                    }
                    
                    if (plant.type === 'snapdragon' && now - plant.lastFire >= levelStats.fireRate) {
                        const zombiesInRange = this.zombies.filter(z => 
                            z.row === plant.row && 
                            z.x > plant.col * (window.innerWidth - 40) / 9 &&
                            z.x < plant.col * (window.innerWidth - 40) / 9 + levelStats.range
                        );
                        
                        if (zombiesInRange.length > 0) {
                            this.fireBreath(plant, zombiesInRange, levelStats);
                            plant.lastFire = now;
                        }
                    }
                    
                    if (plant.type === 'magnetshroom' && now - plant.lastMagnet >= levelStats.cooldown) {
                        const metalZombies = this.zombies.filter(z => 
                            z.row === plant.row && 
                            (z.hasBucket || z.hasHelmet) &&
                            Math.abs(z.x - (plant.col * (window.innerWidth - 40) / 9)) < levelStats.range
                        );
                        
                        if (metalZombies.length > 0) {
                            this.removeMetal(metalZombies);
                            plant.lastMagnet = now;
                        }
                    }
                    
                    if (plant.type === 'cactus' && now - plant.lastFire >= levelStats.fireRate) {
                        const zombie = this.zombies.find(z => z.row === plant.row && z.x > plant.col * (window.innerWidth - 40) / 9);
                        if (zombie) {
                            this.firePea(plant, levelStats.damage);
                            plant.lastFire = now;
                        }
                    }
                    
                    if (plant.type === 'lightningreed' && now - plant.lastFire >= levelStats.fireRate) {
                        const zombiesInLane = this.zombies.filter(z => z.row === plant.row);
                        if (zombiesInLane.length > 0) {
                            this.fireChainLightning(plant, zombiesInLane, levelStats);
                            plant.lastFire = now;
                        }
                    }
                    
                    if (plant.type === 'chomper' && !plant.chewing) {
                        const zombie = this.zombies.find(z => 
                            z.row === plant.row && 
                            Math.abs(z.x - (plant.col * (window.innerWidth - 40) / 9)) < 50
                        );
                        if (zombie && !zombie.isBoss) {
                            this.chomperEat(plant, zombie, levelStats.chewTime);
                        }
                    }
                });
                
                this.handleSpikeweedDamage();
            }
            
            updateZombies() {
                const now = Date.now();
                
                if (now - this.zombieGroanTimer > 5000 && this.zombies.length > 0) {
                    if (Math.random() < 0.3) {
                        this.soundEngine.zombieGroan();
                    }
                    this.zombieGroanTimer = now;
                }
                
                this.zombies.forEach((zombie, index) => {
                    if (this.frozenZombies.has(zombie)) {
                        return;
                    }
                    
                    if (!zombie.eating) {
                        if (zombie.type === 'newspaper' && zombie.hasNewspaper && zombie.health < zombie.maxHealth * 0.5) {
                            zombie.hasNewspaper = false;
                            zombie.enraged = true;
                            zombie.speed = this.zombieTypes.newspaper.enragedSpeed;
                            zombie.element.style.filter = 'hue-rotate(0deg) brightness(1.2)';
                            this.soundEngine.newspaperRage();
                        }
                        
                        if (zombie.type === 'digger' && zombie.underground && zombie.x < window.innerWidth * 0.3) {
                            zombie.underground = false;
                            zombie.x = 50;
                            zombie.element.classList.remove('underground');
                            this.soundEngine.diggerEmerge();
                        }
                        
                        if (zombie.type === 'zomboni' && zombie.createsIce) {
                            const col = Math.floor((zombie.x - 20) / ((window.innerWidth - 40) / 9));
                            const key = `${zombie.row},${col}`;
                            if (col >= 0 && col < 9 && !this.iceTrails.has(key)) {
                                this.createIceTrail(zombie.row, col);
                                if (Math.random() < 0.1) this.soundEngine.zomboniMove();
                            }
                        }
                        
                        if (zombie.type === 'gargantuar' && Math.random() < 0.05) {
                            this.soundEngine.gargantuarStomp();
                        }
                        
                        zombie.x -= zombie.speed / 60;
                        zombie.element.style.left = zombie.x + 'px';
                    }
                    
                    if (zombie.x < -50) {
                        if (this.lawnMowers[zombie.row]) {
                            this.activateLawnMower(zombie.row);
                        } else {
                            this.gameOver();
                        }
                        return;
                    }
                    
                    // Calculate which column the zombie is in using original positioning
                    const col = Math.floor((zombie.x - 20) / ((window.innerWidth - 40) / 9));
                    const plantKey = `${zombie.row},${col}`;
                    const plant = this.plants.get(plantKey);
                    
                    if (plant && zombie.flying && plant.isGround) {
                        return;
                    }
                    
                    if (plant && !zombie.eating && !plant.isGround) {
                        zombie.eating = true;
                        zombie.target = plant;
                    }
                    
                    if (zombie.eating && zombie.target) {
                        let damage = zombie.damage / 60;
                        
                        if (zombie.crushes) {
                            damage = zombie.target.health;
                        }
                        
                        zombie.target.health -= damage;
                        if (zombie.target.health <= 0) {
                            zombie.target.element.remove();
                            this.plants.delete(plantKey);
                            zombie.eating = false;
                            zombie.target = null;
                            
                            if (zombie.type === 'gargantuar' && zombie.health < zombie.maxHealth * 0.5 && !zombie.threwImp) {
                                this.spawnImp(zombie.row);
                                zombie.threwImp = true;
                            }
                        }
                    }
                });
            }
            
            firePea(plant, damage) {
                const projectile = {
                    x: plant.col * (window.innerWidth - 40) / 9 + 50,
                    y: plant.row * (window.innerHeight - 180) / 5 + 120,
                    row: plant.row,
                    damage: damage,
                    type: plant.type, // Track which plant fired this projectile
                    originalDamage: damage, // Store original damage for torchwood boost
                    element: this.createProjectileElement(plant.type)
                };
                
                projectile.element.style.left = projectile.x + 'px';
                projectile.element.style.top = projectile.y + 'px';
                
                this.projectiles.push(projectile);
                this.soundEngine.peaShoot();
            }
            
            createProjectileElement(type) {
                const projectileEl = document.createElement('div');
                projectileEl.className = 'projectile';
                
                // Different projectile styles for different plants
                if (type === 'peashooter') {
                    projectileEl.style.background = '#90EE90';
                    projectileEl.style.borderRadius = '50%';
                } else if (type === 'repeater') {
                    projectileEl.style.background = '#32CD32';
                    projectileEl.style.borderRadius = '50%';
                    projectileEl.style.boxShadow = '0 0 8px #32CD32';
                }
                
                document.querySelector('.game-board').appendChild(projectileEl);
                return projectileEl;
            }
            
            updateProjectiles() {
                this.projectiles.forEach((projectile, index) => {
                    projectile.x += 300 / 60;
                    projectile.element.style.left = projectile.x + 'px';
                    
                    // Check if projectile passes through torchwood
                    const projectileCol = Math.floor((projectile.x - 20) / ((window.innerWidth - 40) / 9));
                    const torchwoodKey = `${projectile.row},${projectileCol}`;
                    const torchwood = this.plants.get(torchwoodKey);
                    
                    if (torchwood && torchwood.type === 'torchwood' && !projectile.boosted) {
                        const levelStats = this.plantTypes.torchwood.levels[torchwood.level];
                        projectile.damage = projectile.originalDamage * (1 + levelStats.damageBoost);
                        projectile.boosted = true;
                        
                        // Visual effect for boosted projectile
                        if (projectile.type === 'peashooter' || projectile.type === 'repeater') {
                            projectile.element.style.background = '#FF6347';
                            projectile.element.style.boxShadow = '0 0 10px #FF4500';
                            projectile.element.style.transform = 'scale(1.3)';
                        }
                    }
                    
                    if (projectile.x > window.innerWidth) {
                        projectile.element.remove();
                        this.projectiles.splice(index, 1);
                    }
                });
            }
            
            checkCollisions() {
                // Create a copy of projectiles array to safely modify during iteration
                for (let pIndex = this.projectiles.length - 1; pIndex >= 0; pIndex--) {
                    const projectile = this.projectiles[pIndex];
                    let projectileHit = false;
                    
                    // Check collision with zombies
                    for (let zIndex = 0; zIndex < this.zombies.length; zIndex++) {
                        const zombie = this.zombies[zIndex];
                        
                        if (zombie.row === projectile.row) {
                            // Check if projectile hits zombie (with better collision detection)
                            const zombieLeft = zombie.x;
                            const zombieRight = zombie.x + 50;
                            const projectileX = projectile.x;
                            
                            if (projectileX >= zombieLeft && projectileX <= zombieRight) {
                                // Only hit if zombie is not underground or if it's flying
                                if (!zombie.underground || zombie.flying) {
                                    this.damageZombie(zombie, projectile.damage);
                                    projectile.element.remove();
                                    this.projectiles.splice(pIndex, 1);
                                    projectileHit = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Remove projectile if it went off screen (and wasn't already removed by collision)
                    if (!projectileHit && projectile.x > window.innerWidth + 50) {
                        projectile.element.remove();
                        this.projectiles.splice(pIndex, 1);
                    }
                }
            }
            
            freezeAllZombies(duration) {
                this.zombies.forEach(zombie => {
                    this.frozenZombies.add(zombie);
                    zombie.element.classList.add('frozen');
                });
                
                this.soundEngine.freeze();
                
                setTimeout(() => {
                    this.zombies.forEach(zombie => {
                        this.frozenZombies.delete(zombie);
                        zombie.element.classList.remove('frozen');
                    });
                }, duration);
            }
            
            fireBreath(plant, zombies, stats) {
                zombies.forEach(zombie => {
                    this.damageZombie(zombie, stats.damage);
                    
                    const fireEffect = document.createElement('div');
                    fireEffect.className = 'fire-effect';
                    fireEffect.style.left = zombie.x + 'px';
                    fireEffect.style.top = zombie.y + 'px';
                    document.querySelector('.game-board').appendChild(fireEffect);
                    
                    setTimeout(() => fireEffect.remove(), 300);
                });
                
                this.soundEngine.fireBreath();
            }
            
            removeMetal(zombies) {
                zombies.forEach(zombie => {
                    if (zombie.hasBucket) {
                        zombie.hasBucket = false;
                        zombie.health = Math.min(zombie.health, this.zombieTypes.basic.health);
                        zombie.maxHealth = this.zombieTypes.basic.health;
                    }
                    if (zombie.hasHelmet && zombie.type !== 'football') {
                        zombie.hasHelmet = false;
                        zombie.health = Math.min(zombie.health, this.zombieTypes.basic.health);
                        zombie.maxHealth = this.zombieTypes.basic.health;
                    }
                });
                
                this.soundEngine.magnetPull();
            }
            
            handleSpikeweedDamage() {
                this.plants.forEach(plant => {
                    if (plant.type === 'spikeweed') {
                        const plantType = this.plantTypes[plant.type];
                        const levelStats = plantType.levels[plant.level];
                        
                        this.zombies.forEach(zombie => {
                            const col = Math.floor((zombie.x - 20) / ((window.innerWidth - 40) / 9));
                            if (zombie.row === plant.row && col === plant.col && !zombie.flying) {
                                this.damageZombie(zombie, levelStats.damage / 60);
                                if (Math.random() < 0.1) this.soundEngine.spikeDamage();
                            }
                        });
                    }
                    
                    // Handle potato mine explosions
                    if (plant.type === 'potatomine') {
                        const plantType = this.plantTypes[plant.type];
                        const levelStats = plantType.levels[plant.level];
                        
                        this.zombies.forEach(zombie => {
                            const col = Math.floor((zombie.x - 20) / ((window.innerWidth - 40) / 9));
                            if (zombie.row === plant.row && col === plant.col && !zombie.flying) {
                                this.explodePotatoMine(plant, levelStats.explosionDamage);
                            }
                        });
                    }
                });
            }
            
            createIceTrail(row, col) {
                const key = `${row},${col}`;
                this.iceTrails.add(key);
                
                const iceTrail = document.createElement('div');
                iceTrail.className = 'ice-trail';
                
                // CSS grid has 20px padding and 2px gap between cells
                // Each cell width/height needs to account for the gaps
                const totalWidth = window.innerWidth - 40; // minus left/right padding
                const totalHeight = window.innerHeight - 180 - 40; // minus UI height and top/bottom padding
                const gapSize = 2;
                
                // Calculate cell dimensions accounting for gaps
                const cellWidth = (totalWidth - (8 * gapSize)) / 9; // 8 gaps between 9 columns
                const cellHeight = (totalHeight - (4 * gapSize)) / 5; // 4 gaps between 5 rows
                
                // Calculate position accounting for padding and gaps
                const x = 20 + col * (cellWidth + gapSize);
                const y = 100 + row * (cellHeight + gapSize); // 100 = 80px UI + 20px top padding
                
                iceTrail.style.left = x + 'px';
                iceTrail.style.top = y + 'px';
                iceTrail.style.width = cellWidth + 'px';
                iceTrail.style.height = cellHeight + 'px';
                
                document.querySelector('.game-board').appendChild(iceTrail);
            }
            
            spawnImp(row) {
                const zombieData = this.zombieTypes.imp;
                const imp = {
                    type: 'imp',
                    row: row,
                    x: window.innerWidth * 0.7,
                    y: 100 + row * (window.innerHeight - 180) / 5,
                    health: zombieData.health,
                    maxHealth: zombieData.health,
                    speed: zombieData.speed,
                    damage: zombieData.damage,
                    eating: false,
                    element: this.createZombieElement(zombieData.emoji)
                };
                
                imp.element.style.left = imp.x + 'px';
                imp.element.style.top = imp.y + 'px';
                imp.element.style.transform = 'scale(0.7)';
                
                this.zombies.push(imp);
                this.soundEngine.impLaunch();
            }
            
            explodeCherryBomb(plant) {
                const plantType = this.plantTypes[plant.type];
                const levelStats = plantType.levels[plant.level];
                
                // Calculate grid-aware positioning (same as ice trails)
                const totalWidth = window.innerWidth - 40; // minus left/right padding
                const totalHeight = window.innerHeight - 180 - 40; // minus UI height and top/bottom padding
                const gapSize = 2;
                
                // Calculate cell dimensions accounting for gaps
                const cellWidth = (totalWidth - (8 * gapSize)) / 9; // 8 gaps between 9 columns
                const cellHeight = (totalHeight - (4 * gapSize)) / 5; // 4 gaps between 5 rows
                
                // Calculate position accounting for padding and gaps
                const cellX = 20 + plant.col * (cellWidth + gapSize);
                const cellY = 100 + plant.row * (cellHeight + gapSize); // 100 = 80px UI + 20px top padding
                
                // Center the explosion in the cell
                const explosionSize = Math.max(cellWidth, cellHeight) * 1.2; // Make it slightly larger than cell
                const centerX = cellX + (cellWidth / 2) - (explosionSize / 2);
                const centerY = cellY + (cellHeight / 2) - (explosionSize / 2);
                
                const explosion = document.createElement('div');
                explosion.className = 'explosion';
                explosion.style.left = centerX + 'px';
                explosion.style.top = centerY + 'px';
                explosion.style.width = explosionSize + 'px';
                explosion.style.height = explosionSize + 'px';
                document.querySelector('.game-board').appendChild(explosion);
                
                this.soundEngine.explosion();
                
                setTimeout(() => explosion.remove(), 500);
                
                // Calculate explosion center for damage calculation
                const explosionCenterX = cellX + (cellWidth / 2);
                const explosionCenterY = cellY + (cellHeight / 2);
                
                this.zombies.forEach(zombie => {
                    const distance = Math.sqrt(
                        Math.pow(zombie.x - explosionCenterX, 2) +
                        Math.pow(zombie.y - explosionCenterY, 2)
                    );
                    
                    if (distance <= levelStats.explosionRadius) {
                        this.damageZombie(zombie, levelStats.explosionDamage);
                    }
                });
                
                const key = `${plant.row},${plant.col}`;
                plant.element.remove();
                this.plants.delete(key);
            }
            
            activateLawnMower(row) {
                const mower = document.getElementById(`mower-${row}`);
                if (!mower) return;
                
                this.lawnMowers[row] = false;
                mower.classList.add('active');
                this.soundEngine.lawnMowerStart();
                
                const zombiesInRow = this.zombies.filter(zombie => zombie.row === row);
                zombiesInRow.forEach(zombie => {
                    zombie.element.remove();
                    const index = this.zombies.indexOf(zombie);
                    this.zombies.splice(index, 1);
                    this.score += 10;
                });
                
                setTimeout(() => {
                    mower.remove();
                }, 2000);
            }
            
            startGameLoop() {
                const gameLoop = () => {
                    if (!this.gameRunning) return;
                    
                    if (!this.gamePaused) {
                        this.updatePlants();
                        this.updateZombies();
                        this.updateProjectiles();
                        this.checkCollisions();
                    }
                    
                    this.updateUI();
                    
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }
            
            damageZombie(zombie, damage) {
                zombie.health -= damage;
                
                const damageText = document.createElement('div');
                damageText.className = 'damage-text';
                damageText.textContent = Math.round(damage);
                damageText.style.left = zombie.x + 'px';
                damageText.style.top = zombie.y + 'px';
                document.querySelector('.game-board').appendChild(damageText);
                
                setTimeout(() => damageText.remove(), 1000);
                
                const healthFill = zombie.element.querySelector('.health-fill');
                healthFill.style.width = (zombie.health / zombie.maxHealth * 100) + '%';
                
                if (Math.random() < 0.3) {
                    this.soundEngine.zombieHit();
                }
                
                if (zombie.type === 'balloon' && zombie.health <= 0) {
                    this.soundEngine.balloonPop();
                }
                
                if (zombie.health <= 0) {
                    zombie.element.remove();
                    const index = this.zombies.indexOf(zombie);
                    this.zombies.splice(index, 1);
                    this.score += 10;
                    this.soundEngine.zombieDeath();
                }
            }
            
            updateUI() {
                document.getElementById('sun').textContent = this.sun;
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('score').textContent = this.score;
                
                document.querySelectorAll('.plant-card').forEach(card => {
                    const plantType = card.dataset.plant;
                    const cost = this.plantTypes[plantType].cost;
                    card.classList.toggle('disabled', this.sun < cost);
                });
            }
            
            gameOver() {
                this.gameRunning = false;
                this.soundEngine.gameOver();
                
                const gameOverEl = document.createElement('div');
                gameOverEl.className = 'game-over';
                gameOverEl.innerHTML = `
                    <div>GAME OVER</div>
                    <div style="font-size: 24px; margin-top: 10px;">Wave ${this.wave} | Score: ${this.score}</div>
                    <button class="restart-btn" onclick="location.reload()">Play Again</button>
                `;
                document.querySelector('.game-container').appendChild(gameOverEl);
                
                const restartBtn = gameOverEl.querySelector('.restart-btn');
                restartBtn.addEventListener('click', () => {
                    this.soundEngine.buttonClick();
                });
            }
            
            explodePotatoMine(plant, damage) {
                // Calculate grid-aware positioning
                const totalWidth = window.innerWidth - 40;
                const totalHeight = window.innerHeight - 180 - 40;
                const gapSize = 2;
                
                const cellWidth = (totalWidth - (8 * gapSize)) / 9;
                const cellHeight = (totalHeight - (4 * gapSize)) / 5;
                
                const cellX = 20 + plant.col * (cellWidth + gapSize);
                const cellY = 100 + plant.row * (cellHeight + gapSize);
                
                const explosion = document.createElement('div');
                explosion.className = 'explosion';
                explosion.style.left = cellX + 'px';
                explosion.style.top = cellY + 'px';
                explosion.style.width = cellWidth + 'px';
                explosion.style.height = cellHeight + 'px';
                document.querySelector('.game-board').appendChild(explosion);
                
                this.soundEngine.explosion();
                setTimeout(() => explosion.remove(), 500);
                
                // Damage zombies in area
                const explosionCenterX = cellX + (cellWidth / 2);
                const explosionCenterY = cellY + (cellHeight / 2);
                
                this.zombies.forEach(zombie => {
                    const distance = Math.sqrt(
                        Math.pow(zombie.x - explosionCenterX, 2) +
                        Math.pow(zombie.y - explosionCenterY, 2)
                    );
                    
                    if (distance <= 100) {
                        this.damageZombie(zombie, damage);
                    }
                });
                
                // Remove the potato mine
                const key = `${plant.row},${plant.col}`;
                plant.element.remove();
                this.plants.delete(key);
            }
            
            fireChainLightning(plant, zombies, stats) {
                const sortedZombies = zombies.sort((a, b) => a.x - b.x);
                const targetCount = Math.min(stats.chainCount, sortedZombies.length);
                
                for (let i = 0; i < targetCount; i++) {
                    this.damageZombie(sortedZombies[i], stats.damage);
                    
                    // Create lightning effect
                    const lightningEffect = document.createElement('div');
                    lightningEffect.className = 'lightning-effect';
                    lightningEffect.style.left = sortedZombies[i].x + 'px';
                    lightningEffect.style.top = sortedZombies[i].y + 'px';
                    lightningEffect.style.width = '20px';
                    lightningEffect.style.height = '40px';
                    lightningEffect.style.background = 'linear-gradient(45deg, #FFD700, #FFFF00)';
                    lightningEffect.style.position = 'absolute';
                    lightningEffect.style.zIndex = '15';
                    lightningEffect.style.animation = 'lightning 0.3s ease-out forwards';
                    document.querySelector('.game-board').appendChild(lightningEffect);
                    
                    setTimeout(() => lightningEffect.remove(), 300);
                }
                
                this.soundEngine.createTone(800, 0.2, 'square', 0.3);
            }
            
            chomperEat(plant, zombie, chewTime) {
                plant.chewing = true;
                plant.target = zombie;
                
                // Remove zombie immediately
                zombie.element.remove();
                const zombieIndex = this.zombies.indexOf(zombie);
                this.zombies.splice(zombieIndex, 1);
                this.score += 10;
                
                // Show chomper is chewing
                plant.element.style.filter = 'hue-rotate(90deg)';
                this.soundEngine.createTone(150, 0.5, 'sawtooth', 0.2);
                
                setTimeout(() => {
                    plant.chewing = false;
                    plant.target = null;
                    plant.element.style.filter = '';
                }, chewTime);
            }
        }
        
        // Initialize the game
        new Game();
    </script>
</body>
</html>
            